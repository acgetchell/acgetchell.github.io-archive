---
layout: post
title: "Lisp Conversion"
date: 2011-12-01
comments: false
categories:
 - lisp
 - cdt
 - tdd
 - clojure
---

<div class='post'>
A few months and a lot of Lisp later, I find myself convinced/converted ...<br /><br />... To <a href="http://clojure.org/">Clojure</a>.<br /><br />Rajesh, you were right!<br /><br />As far as language <strike>snobbery</strike> coolness, it has a bunch of features I like such as:<br /><ul><li>A <a href="http://clojure.org/dynamic">REPL</a> for fast development</li><li><a href="http://clojure.org/functional_programming">Functional programming</a> with <a href="http://thinkrelevance.com/blog/2008/09/16/pcl-clojure-chapter-6.html">immutable values</a>&nbsp;which makes it easy to reason about concurrency</li><li><a href="http://clojure.org/concurrent_programming">Concurrent programming</a> via <a href="http://clojure.org/refs">software transactional memory</a></li><li>A <a href="http://hornbeck.wordpress.com/2009/07/05/lisp-1-vs-lisp-2/">Lisp-1</a> <a href="http://clojure.org/lisp">dialect</a></li><li>OOP benefits without OOP using <a href="http://clojure.org/runtime_polymorphism">runtime polymorphism</a></li><li>Lots of modern libraries by being <a href="http://clojure.org/jvm_hosted">hosted on the JVM</a></li><li>A <a href="http://groups.google.com/group/clojure">vibrant community</a>&nbsp;(my <a href="http://groups.google.com/group/fsharp-opensource">F# groups</a>, by contrast, have had barely 2 messages in the past month)</li></ul>To get an idea of what I mean, here's an anonymous function to find the odd numbers in a (lazy) <a href="http://clojure.org/sequences">sequence</a> (which could be a list, vector, or hash map):<br /><br /><script src="https://gist.github.com/1354304.js">  </script><br />This idea of <a href="http://formpluslogic.blogspot.com/2009/07/clojure-lazy-seq-and-recursion.html">lazy sequences</a> is powerful, because you can do things like get the <a href="http://clojure-euler.wikispaces.com/Problem+007">10,001st prime number</a> without blowing the stack:<br /><script src="https://gist.github.com/1416617.js">  </script><br />You can just see the number-crunchy goodness, mixed in with Lispy functional precision.<br /><br />As far as practicality, there is simply too much awesome stuff.<br /><ul><li>The language itself is available on <a href="https://github.com/clojure/clojure">GitHub</a></li><li>It has nice <a href="http://clojuredocs.org/">documentation</a>&nbsp;to <a href="http://dev.clojure.org/display/doc/Getting+Started">get you started</a> quickly</li><li>There are great learning resources:&nbsp;<a href="http://www.4clojure.com/">4Clojure</a>&nbsp;<a href="https://github.com/functional-koans/clojure-koans">clojure-koans</a></li><li>Nice examples of algorithms such as&nbsp;<a href="http://www.algolist.net/Algorithms/Sorting/Quicksort">Quicksort</a> using&nbsp;<a href="http://rosettacode.org/wiki/Sorting_algorithms/Quicksort#Clojure">Clojure</a></li><li><a href="http://thinkrelevance.com/blog/2008/09/16/pcl-clojure.html">Easy translation</a> from <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a></li><li>A <a href="http://www.jetbrains.com/idea/download/index.html">freely available</a> <a href="http://www.jetbrains.com/idea/">killer IDE</a> <a href="http://plugins.intellij.net/plugin/?id=4050">supporting Clojure</a> with <a href="https://github.com/technomancy/leiningen">project building</a> and GitHub support</li><li><a href="http://webnoir.org/">Simple</a> to <a href="https://github.com/weavejester/compojure/wiki">complex</a> web application support to <a href="http://mmcgrana.github.com/2010/07/develop-deploy-clojure-web-applications.html">EC2</a>, <a href="http://blog.heroku.com/archives/2011/7/5/clojure_on_heroku/">Heroku</a>, <a href="http://googlecode.blogspot.com/2010/05/better-performance-in-app-engine-with.html">Google App Engine</a> and others</li></ul>You can easily do TDD (test driven development), which is really handy if, say, you've got a bunch of math functions that you want to be sure are correct when you port/rewrite code.<br /><br />Here's a screenshot of <a href="http://www.jetbrains.com/idea/">IntelliJ</a> with a typical <a href="https://github.com/technomancy/leiningen">Leiningen</a> project open:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-M-dYvAMiipM/TtfPdohU_mI/AAAAAAAA_vE/NeiVEH5OKHs/s1600/idea-lein.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="432" src="http://4.bp.blogspot.com/-M-dYvAMiipM/TtfPdohU_mI/AAAAAAAA_vE/NeiVEH5OKHs/s640/idea-lein.png" width="640" /></a></div><br /><br />You can see the typical Leiningen project layout, with /src and /test folders and subfolders. First, we'll write a <strike>function</strike>&nbsp;test for a function we want which sums over all values in a given sequence:<br /><br /><script src="https://gist.github.com/1419076.js">  </script><br />The test is in C:\Projects\CDT\Newton\test\Newton.test\core.clj, and the :use [Newton.utilities] tells it to look in the file C:\Projects\CDT\Newton\src\Newton\utilities.clj for our function. Note the use of metadata ^{:utilities true} to mark this as a utilities test, which we'll use later for organization. Our test checks that our to-be-defined sum test sums correctly over both a list and a vector.<br /><br />Now here's the contents of C:\Projects\CDT\Newton\src\Newton\utilities.clj:<br /><br /><script src="https://gist.github.com/1419125.js">  </script><br />Finally, Leiningen allows us to choose test selectors so that we can specify which tests we want to run via project.clj:<br /><br /><script src="https://gist.github.com/1419165.js">  </script><br />Now by running lein at a command prompt (to save startup time) we can pick our tests: <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-myffmQYgpC8/TtfWhU5qTQI/AAAAAAAA_vM/uTxhOaHJSO4/s1600/lein.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://1.bp.blogspot.com/-myffmQYgpC8/TtfWhU5qTQI/AAAAAAAA_vM/uTxhOaHJSO4/s640/lein.png" width="640" /></a></div><br /><br />Note in the first case, we don't expect any tests to run (test! means fetch dependencies and then run tests) because our sole test has been marked as a :utility. In the second case, we tell it to run :utility and it does, telling us that our test passed. Success!<br /><br />If our test had failed, clojure's test suite would give us good information. Here, I'm going to modify the second assertion to fail. Watch what happens:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-CqWRxYR47_Y/TtfXz8Po9GI/AAAAAAAA_vU/RvqznnUbXSk/s1600/lein-test-fail.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://4.bp.blogspot.com/-CqWRxYR47_Y/TtfXz8Po9GI/AAAAAAAA_vU/RvqznnUbXSk/s640/lein-test-fail.png" width="640" /></a></div><br />How cool is that?<br /><br />I've so far read <a href="http://www.manning.com/rathore/">Clojure in Action</a> and <a href="http://joyofclojure.com/">The Joy of Clojure</a>&nbsp;(both highly recommended), plus enough daily doses &nbsp;to actually stop mucking about and start with the <a href="https://github.com/ucdavis/CDT">CDT code</a> already.<br /><br />So, a modern Lisp with powerful IDEs, modern libraries from the JVM, interactive REPL/TDD, great documentation, learning resources, and books -- what's not to like?<br /><br /></div>
