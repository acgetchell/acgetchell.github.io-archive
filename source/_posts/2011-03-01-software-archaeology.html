---
layout: post
title: "Software Archaeology"
date: 2011-03-01
comments: false
categories:
 - programming
---

<div class='post'>
<a href="http://en.wikipedia.org/wiki/Vernor_Vinge">Vernor Vinge</a> prophetically <a href="http://books.slashdot.org/story/03/09/18/0411259/Review-A-Fire-Upon-the-Deep-Special-Edition">wrote of a time</a> when programmer-archaeologists maintained the fabric of civilization by diving into and modifying legacy code which ran the systems that society depended upon.<div><br /></div><div>Various other folks have picked up on this notion, from the <a href="http://java.sys-con.com/node/487614">serious</a> to the <a href="http://giant-communist-robots.com/?p=154">humorous</a>. Here, though, I'll talk about this from my own perspective (which is what you came here for, right?).</div><div><br /></div><div><a href="http://www.ieee.org/portal/cms_docs_societies/sscs/PrintEditions/200804.pdf">Kernighan's</a> saw goes that debugging code is twice as hard as writing it; therefore we ought to keep our meaning clear and our code as simple as possible. How to do so?</div><div><br /></div><div>There are clear debates about that: <a href="http://msdn.microsoft.com/en-us/library/bb669144.aspx">functional vs. declarative</a>, <a href="http://www.virtuosimedia.com/dev/php/procedural-vs-object-oriented-programming-oop">procedural vs. object-oriented</a>, not to mention <a href="http://books.google.com/books?hl=en&amp;lr=&amp;id=HBAuixGMYWEC&amp;oi=fnd&amp;pg=PA383&amp;dq=patterns+and+antipatterns&amp;ots=emzw4QN8Dj&amp;sig=AFOJ5TeY4zHfa1pCKky8ux_X9hQ#v=onepage&amp;q=patterns%20and%20antipatterns&amp;f=false">Patterns &amp; Anti-Patterns</a>, <a href="http://martinfowler.com/articles/injection.html">Dependency Injection/Loose Coupling</a>, <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-Oriented Programming</a>, etc. etc. These can be very fun to get into and there are diverse and subtle points all around, that I won't attempt to do them justice here but if you've a free week or two read any of the above links and the next five references thereafter and you'll come away more enlightened, or more confused.</div><div><br /></div><div>But in the meantime, you've either got to a) emit working code or b) manage those who do a). And if you could do so without too badly embarrassing yourself in the future (which is nigh impossible), or at least, be willing to chalk them up as learning experiences, you're well on your way to some sort of nirvana of ineffable, crystallized logic which is a perfect solution to your problem.</div><div><br /></div>


<!--more-->

<div>(Getting a clear problem statement itself being at least half of the battle and most of the difficulty, given business processes that aren't well understood, or mutate depending upon who's doing them or in which context. But that discussion more properly belongs in the realm of project management and business analysis, and won't be further remarked upon here.)</div><div><br /></div><div>If you're not a coder yourself (or horribly out of date), you can still make a fair crack at judging the product by the team. <a href="http://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959">The Mythical Man-Month</a> is the canonical reference, but <a href="http://www.joelonsoftware.com/">Joel Spolsky's</a> <a href="http://www.joelonsoftware.com/articles/fog0000000043.html">Joel Test</a> is pretty concise, descriptive, and useful.</div><div><br /></div><div>Archaeology can imply adventurous, sunburned types digging around fossil layers high in vast dusty mesas of stratified rock. And truth be told, that's not a bad analogy for the cacophony of systems that the average IT organization has inherited, cobbled together, purchased (often from a now-defunct vendor), or perhaps in a fit of creativity -- produced. After all, post dot-com, <a href="http://footheory.com/blogs/donnfelker/archive/2008/05/05/software-development-greeenfield-vs-brownfield.aspx">Greenfield development</a> is rare.</div><div><br /></div><div>But Brownfield development is often so painful that most developers will throw up their hands and rewrite from scratch, rather than attempting to piece together the workings of an often poorly documented system written with "ancient" methods/languages.</div><div><br /></div><div>Hence, onto the first item on the Joel Test: source control.</div><div><br /></div><div>But not just any source control. <a href="https://github.com/">GitHub</a>.</div><div><br /></div><div>Why GitHub? Well, first, it has the elusive "Alpha Coder mindshare". While it may not matter one way or another to your business that the Linux kernel, Git itself, jQuery, Ruby on Rails, and a host of other important projects exist on GitHub, it matters to your programmers, whether they know it or not (and the good ones will know it).</div><div><br /></div><div>All of these actively maintained open source projects provide something more interesting than mindshare: examples. Pick a programming language, and you will very likely find an interesting project or two on GitHub that has something worth learning. It may even prove to be the Rosetta stone of programming languages -- you may find solutions to the same problem in many different programming languages.</div><div><br /></div><div>Second, <a href="http://radar.oreilly.com/2009/01/github-making-code-more-social.html">Social Coding</a>. Everyone knows of the usefulness of social networks -- they existed before, but it's the tools that made them marketable/actionable. Social coding in GitHub takes the usual forms -- followers, blogs, wikis, issues, teams, organizations -- plus some more useful ones (e.g. the <a href="http://develop.github.com/">GitHub API</a>).</div><div><br /></div><div>We used Team Foundation Server. It was a nice tool in our .NET development shop -- a bit painful to setup with it's dependence on SharePoint, but useful. However, it didn't scale too well in terms of collaborators. We needed to add them as users into Active Directory, fuss about with SharePoint and licensing, and so forth.</div><div><br /></div><div>So next we tried <a href="http://www.codeplex.com/">CodePlex</a>. CodePlex was, essentially, TFS in the cloud, and it mostly worked. There were capacity issues, and it wasn't always friendly with non .NET languages, but the main reason we didn't adopt it wholesale was:</div><div><ol><li>No way to make private repositories</li><li>Often painful to connect into</li><li>Went down/was slow often enough that we didn't want to rely on it.</li></ol><div>This really illustrates the third virtue of GitHub, that it's a true cloud service -- but cloud computing is all the hype right now and I really wanted to illustrate it's particular benefits in this instance.</div></div><div><br /></div><div>In going with GitHub, we created an organization for our, well, organization. This gives us several important advantages over CodePlex:</div><div><ol><li>Private repositories</li><li>Teams</li><li>Unlimited collaborators (in particular, we can mix and match between general GitHub accounts and team members)</li><li>Blogs, Wikis, Gists, Issue Trackers with voting, per-line file commenting, and other social features</li><li>Works well with any programming language</li><li>Fast, decentralized development (Git works locally, so you can get on a plane, code, and upload your changes once you've got internet access)</li><li>Reliable versioning (Git uses hashes for files)</li><li>Works well with any OS/IDE (Git has integration with Visual Studio, Eclipse, XCode plus command-line versions in most every OS)</li><li>Git is a well-regarded distributed version control system (DCVS)</li></ol><div>My programming team ported projects over from TFS and CodePlex in under a day. By following projects, I can watch check-ins, view version differences, open/close issues, and do all the usual software management stuff without getting in the way. (Or better yet, delegate.)</div></div><div><br /></div><div>The fees are pretty nominal (organizations get charged based on the numbers of private repositories they want; public ones are free). GitHub is hosted by RackSpace, so the reliability has been better than our in-house TFS boxes. Today I just added someone outside our organization to one of our projects with minimal hassle.</div><div><br /></div><div>If you're going to be digging up fossilized code, Git and GitHub are fairly pleasant tools for the job.</div><div><br /></div><div>Look at the time! This isn't really everything I wanted to say, but I've probably said enough for now (and I have other pressing priorities including my own research), so I'll leave further pontificating for another time.</div><div><br /></div><div>I hope this was informative, or at least, entertaining!</div><div><br /></div><div>(You can find me on GitHub <a href="https://github.com/acgetchell">here</a>!)</div><div><br /></div></div>
